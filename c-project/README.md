
# C 语言学习笔记

```asm
使用define定义常量
#define PI 3.14

const  用于限定一个变量只读 ,用起来比 #define 更灵活
const int MONTHS=12;

```

在C语言中，字符串是以空字符(ASCII码是0) 结尾的一系列字符。可以把字符串存储在字符数组中。

**const 修饰的表示只读**。



# 指针

**指针**:  是一个值为内存地址的变量(或数据对象)。

## **&运算符**

也称为地址运算符。

 一元运算符给出变量的存储地址。 如果 **pooh** 是变量名，那么**&pooh**是变量的地址。 可以把地址看作是变量在内存中的位置。



## 间接运算符 * 

已知指针： ptr 

ptr = &bah;

使用间接运算符* 找出存储在bah 中的值 ，该运算符有时也称解引用运算符。

```c
val = * ptr;  //找出指向ptr的值

语句 ptr = &bah ; 和val = *ptr ; 放在一起相当于下面的语句:
val = bash;
```

由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。

## 声明一个指针

```c
int  * pi ; // pi 是指向int 类型变量的指针.
char * pc ; // pc 是指向char 类型变量的指针.

星号(*) 和指针名之间的空格可有可无。
```

通常，程序员在**声明时使用空格，在解引用变量时省略空格**。

指针的格式转换使用 %p

```c
printf("%p")
```



# 指针和数组

**数组名** 就是数组首元素的地址，也就是说，如果flizny 是一个数组，下面的语句成立：

```c
flizny == &flizny[0] ; // 数组名就是该数组首元素的地址
%p 通过以16进制显示指针的值
```

```c
total += *start++;
```

```c
一元运算符 * 和 ++ 的优先级相同，但结合律是从右向左， 所以start ++ 先求值，然后再是 *start 。也就是说，指针 start 先递增后指向。 
   使用后缀形式(即 start ++ 而不是 ++start )意味着先把指针指向位置上的值加到total 上，然就再递增指针。 如果使用 *++start , 顺序就反过来，先递增指针，再使用指针指向位置上的值。
  如果使用(*start)++ ，则先使用start 指向的值，再递增该值，而不是递增指针。 这样，指针讲指向同一个位置，但是该位置上的值发生了变化。 
```



**二维数组**

```c
int (*p2)[6]
表示p2指向一个内含6个int类型值得数组。 因此p2[i] 代表一个由6个整数构成的元素，
p2[i][j] 代表一个整数。 
```



# 数组和指针的区别

初始化字符数组来存储字符串和初始化指针来指向字符串有何区别（“指向字符串” 的意思是指向字符串的首字符.）

```c
char heart = "I love T";
const char * head = "I love T"
```

两者的主要区别是：数组名heart 是常量， 而 指针名head 是变量。



# 外部链接的静态变量

为了指出该函数使用了外部变量，可以**在函数中使用关键字extern 再次声明**。 **如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern 在该文件中声明该变量。**



# 分配内存 ： malloc 和  free

这两个一般搭配使用。

每次调用malloc()分配内存给程序使用，每次调用free() 把内存归还内存池中，这样便可以重复使用这些内存。 

不能使用free() 释放通过其它方式(如，声明一个数组) 分配的内存。



程序把静态对象、自动对象和动态分配的对象存储在不同的内存区域.

动态分配的内存在调用malloc()  或相关函数时存在，在调用free() 后释放。 这部分的内存由程序员管理，而不是一套规则。 所以内存块可以在一个函数中创建，在另一个函数中销毁。 



